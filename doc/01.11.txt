01.11

String클래스의 .toUpperCase()메소드는 모든 문자를 대문자로 바꾸어준다.반대로 .toLowerCase()는 소문자로 바꿔준다.
또, equalsIgnoreCae()메소드는 대문자소문자를 무시하고 체크해준다.

다형성의 장점 : 하나의 부모클래스의 메소드를 통해 여러 기능들을 수행(오버라이딩)하게 가능하다.

장점1. 여러타입의 객체를 하나의 타입으로 관리할 수 있기 때문에 유지보수성과 생산성이 증가된다.
장점2. 동일한 메시지를 수신받아 처리하는 내용을 객체별로 다르게 할 수 있다는 장점.(메소드 하나로 관리 가능)
장점3. 매개 변수의 클래스 타입이 각자 달라 오버로딩 된 동일한 이름의 메소드들의 매개변수들을 하나의 부모클래스로 묶어 관리가 가능하다.
장점4.  결합도를 낮춰 유지보수성을 증가시킴

메소드의 매개변수나 리턴타입을 부모클래스 지정하면 자식클래스에 맞는 메소드를 일일이 작성할 필요가 없다.

동적바인딩의 성립 조건 : 상속 관계를 가지는 부모 자식 클래스에 오버라이딩 된 메소드를 호출 해야 한다.

선언을 부모클래스로 해놓았지만 자식 클래스의 멤버를 써야할 경우 명시적으로 형변환을 해주는 것을 다운캐스팅이라고 한다.

안전한 형 변환을 위해 instanceof연산자를 쓸 수 있다. 존재하는 타입과 형변환하려는 타입이 일치하지 않는 경우 런타임 에러 발생..

-----------------------------------------------------------------------------------------------------

추상클래스

추상메소드 : 접근제한자 리턴타입 메소드명(매개변수);의 형태
추상클래스 : 추상메소드를 0개이상 포함하는 클래스,인스턴스 생성이 불가능하다. 
* 추상메소드가 있는 클래스는 자동으로 추상클래스가 된다.->추상클래스=불완전한클래스

그렇다면 객체를 만들지 않을꺼면 왜필요할까?
부모로 만들고 싶은 것이다. 상속을 활용해 자식클래스에서 구체화하기를 바라는 것이다.

일반 클래스에 추상메소드를 넣으면 컴파일 에러뜨면서 클래스명 앞에 abstract를 넣어달라고 요청한다.

추상 클래스를 상속 받은 클래스는 오버라이딩 강제성 부여 아니면 컴파일 에러

추상 클래스를 상속한 클래스가 추상클래스일 수도 있다.

----------------------------------------------------------------------------------------------------------------------
인터페이스

추상클래스에서 한발 더나아간 놈이다.
추상메소드는 일반적인 필드를 가질 수 있었지만 인터페이스는 추상메소드와 상수 필드만 가질 수 있는 
클래스의 변형체이다.

추상클래스의 필드는 public static final이라는 상수필드를 붙혀줘야하는데 붙히지 않고 자료형+변수명만 입력해도 묵시적으로 입력이된다.

인터페이스는 생성자를 가질 수 없다.

인터페이스의 메소드는 구현부가 있는 메소드를 가질 수없고 추상 메소드만 작성이 가능함
묵시적으로 public abstract의미를 가진다.

인스턴스를 만들 수 없기 때문에 static메소드 작성이 가능하다. 또한 default키워드를 사용하면 non-static메소드도 만들 수 있다. (JDK1.8버전부터)-> 
그렇다면 왜 일반 non-static메소드도 몸체까지 작성이 가능하게 갑자기 만든걸까?
Interface에 구현해 놓은 추상메소드들은 모두 자식클래스에서무조건 오버라이딩이 강제되는데 자식클래스에서 필요없을 수도 있는데 default키워드를 사용하여 만든 non-static메소드를 통해 오버라이딩 강제화를 막을 수 있다.

static메소드는 오버라이딩할 수 없다.

default키워드가 들어간 메소드는 오버라이딩이 default를 지운상태에서만 가능하다.

implements는 다중 상속이 가능하다
상속받으면서 동시에 구현받는 것도 가능하다.(extends 먼저 작성)
인터페이스는 인터페이스를 상속할 수 있다. ->extends로 작성
정리) 클래스 extends 클래스 -> 단일상속
클래스 implements 인터페이스1,인터페이스2, ... -> 다중 상속
인터페이스 extends 인터페이스1,인터페이스2, ... -> 다중 상속

인터페이스를 상속받는 클래스의 메소드들을 사용할 때
static이 붙어있으면 인터페이스.메소드명
non-static이면 객체를 만들어야하는데 인터페이스는 객체 만드는 것이 불가능하기 때문에 다형성을 이용해서 객체를 만들어주어야한다. InterProduct interProduct = new Product(); -> 업캐스팅

------

추상클래스는 추상메소드에  abstract를 명시적으로 써줘야하고 인터페이스는 묵시적으로 써주기때문에 써줄 필요가 없다.
왜냐하면 추상클래스에는 일반 메소드들도 올 수 있기 때문이다. 인터페이스에도 일반 메소드는 올 수 있지만 default를 통해 구분해줄 수 있다.
------------------------------

문제 해설

10-> int j =i++;에서 j에 i값이 대입되고 후위연산자실행됨
13-> _public처럼 언더바로 시작하는 것이 가능하다.
14-> 매개변수로 변수를 받는 경우 출력되는 것 조심
15 -> break없는게 함정
16 -> a에 인스턴스 주소값 b에 인스턴스 주소값, c는 a와 같은 인스턴스 주소 참조 d,e는 statck영역의 변수
19 -> 생성자0개일 경우기본 생성자,void메소드return
20 -> 생명주기가 가장 짧은 영역은 stack,가장 긴영역은 static이다 
