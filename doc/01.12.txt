01.12

자주 쓰는 API

Object의 메소드 toString() 현재클래스의 이름+@+16진수 주솟값 -> 기본적인 동작

레퍼런스 변수를 그냥 그 자체를 출력하는 것과 toString()을 이용해서 출력되는 값이 동일하다. ->자동으로 toString()을 호출한다. 

오버라이딩 된 toString(); -> 객체가 가진 필드값을 나타내는 모습

두 인스턴스의 연산 비교 '==' 주소값 비교
두 인스턴스의 equals()연산 비교 -> ==과 마찬가지로 주소값 비교

동일 객체 : 주소가 동일한 인스턴스
동등 객체 : 주소가 다르더라도 필드 값이 동일한 인스턴스

Object의 메소드 equals()메소드도 원래는 동일 객체를 판단하는 메소드이지만 오버라이딩을 통해 동등 객체 기능올 바꾸어준다.

equals를 오버라이딩하면 반드시 hashCode()도 오버라이딩 해줘야한다. 재정의하지 않으면 동등 객체는 같은 해시코드 값을 가져야한다는 규약에 위반된다. 

native라는 키워드 : 자바가아니라 다른언어로 작성되어있다는 의미

오버라이딩 전의 hashCode는 동일 객체 판단이다.

equals 와 hashCode는 둘 다 오버라이딩됬으면 동등 객체를판단한다.

-----------------------------------------------------------------------------------------------------

String클래스

.compareTo(): 비교했을 때 양수인지 음수인지를 판단할 목적 인자가 더 작으면 양수값,인자가 더 크면 음수값이 나온다. 같으면 0이나온다.
.compareToIgnore() : 대소문자를 구분하지 않고 비교
.concat() : 두 문자열을 합침

indexOf() : 인자로 넘어가는 문자를 탐색해서 인덱스 위치를 숫자로 반환해줌, 그 문자가 없으면 -1 출력 여러개 있으면 제일 처음에 있는 문자의 인덱스가 나타남
lastIndexOf(): indexOf()와 같지만 끝에서 부터 탐색한다.

trim() : 공백을 제거해줌
*원본 변경 x

toLowerCase() : 소문자로
toUpperCase() : 대문자로
* 원본 변경 x

subString() : 문자열에서 내가원하는 부분을 잘라올 수 있는
(시작인덱스,오려오고 싶은 마지막 인덱스+1)
(시작인덱스):시작인덱스부터 문자열까지 끝까지

replace() : 문자열에서 대체할 문자열로 기존 문자열을 변경해서 반환한다.
replace(오려오고 싶은 부분,바꾸고 싶은 내용)

.isEmpty() : 문자열이 비어있으면 true반환 아니면 false

String str = null;과 String str2 ="";는 다르다.

null.isEmpty(); 불가능


Object의 hashCode()메소드는 주소값을 비교하여 체크하지만 자식 클래스인 String의 hashCode()는 주소가 달라도 다른 값을 갖는지 체크하는 메소드로 오버라이딩 되어있다.

split()과 StringTokenizer클래스 : 기능은 둘다 문자열을 기준으로 잘라내는 것이 가능하다.
StringTokenizer 라는 객체를 생성하고 new StringTokenizer(문자열,자를 기준)을 통해 사용가능

자를 기준에 따라 토큰들로 분리 .hashMoreTokens()을 통해 true,false값이 나온다.또한 .nextToken()메소드를 통해 다음 값들을 출력할 수 있다. 출력하고나서 토큰은 재사용이 불가능하기 때문에 재출력이 안된다.

split()은 공백을 인정하지만 맨 마지막 공백은 인정하지 않고 StringTokenizer은 공백을 무시한다.

split은 자르고 싶은 문자열이 여러개일 경우 []안에 넣어서해준다.
 StringTokenizer은 그냥 여러개 붙혀서 쓰면된다. */%각각 하나로 인식한다.

이스케이프문자
문자열 내에서 사용하는 문자 중 특수문자를 표현하거나 특수기능을 사용할 때 사용하는 문자이다.

StringBuilder
String은 불변하기 때문에 값을 변경할수 없다. 값이 바뀌는 것은 새로운 객체가 생성되는 것 뿐이다. 이를 해결하기위해 StringBuffer와 StringBuilder가 등장했다.(가변)

싱글쓰레드란??
멀티쓰레드 : 메소드 호출 스택이 하나가 아니라 여러가지이다. 스택이 여러가지 있어서 프로그램의 실행 흐름이 병렬적이다.

쓰레드 세이프 : 하나의 자원에 대해 여러가지 스택에 있는 프로그램들이 병렬적으로 작동하며 원하지 않는 값이 도출 될 수 있기 때문에 lock을 걸어놓은 상태

StringBuilder와 StringBuffer의 메소드가 똑같음 그래서 StringBuilder을 알아볼 것이다.

String : 수정할때마다 새로운 객체 할당해야함 -> 수정할 때마다 시간과 비용이 든다.
문자열을 계속 수정해야하는 상황이 생긴다면 StringBuilder를 선택하자

StringBuilder -> 문자 수정 전 후 의 주소 모두 같음

.capacity()를 통해 용량을 확인 -> 글자를 계속 증가시키다가 용량을 넘어서버리면 용량이 증가함 하지만 계속 글자를 확장시켜도 주소는 같다.

.delete()메소드는 (시작,끝)을 기준으로 인덱싱 된 값을 삭제한다.
.deleteCharAt() 딱 한 글자만 삭제할 때
.insert() 인자로 전달된 값을 문자열로 변환 후 지정한 인덱스 위치에 추가한다. 
.reverse() 거꾸로 출력
이 이외에도 String클래스와 같은 메소드들도 있다.
---------------------------------------------------------------------------------------------------
Wrapper클래스
기본타입의 데이터를 인스턴스화 해야하는 경우에 사용 ex) public void method(Object object){}메소드에서 method(10);을 넣고 싶을 때 int는 넣어주지 못한다. Integer로 변환하여 넘겨줘야한다. 

박싱과 언박싱
기본자료형을 객체로 바꾸는 것이 wrap으로감싸는 것이다. boxing처리(int를 Integer로 만든다.)하는 것이다. 
래퍼클래스 타입의 인스턴스를 기본타입으로 변경하는 것을 unboxing이라고한다.
*오토 박싱과 오토언박싱이 JDK1.5버전부터 해주고 있다.

Integer클래스는 java.lang패키지에 있기때문에 따로 import해줄 필요 없다.

deprecated되었다 = 옛날에는 이 코드를 썼지만 이 코드는 이제쓰지 않을 예정이다.

int num = 10
Integer num2 = num;   //Auto Boxing 자동형변환 된 것이다.

언박싱
Integer타입을 int로 바꿈 
int num4 = num2;//Auto UnBoxing 자동 언박싱 된다.

주소값 == 값 -> 값==값으로 바뀐다. 

-------------------------------------------------------------------------------------

파싱 : 문자열 값을 기본 자료형 값으로 변경한다. 
사용자로부터 받은 값이 문자형인 경우들이 있다.이걸 int값으로 바꾸고 싶을 때의 과정을 parsing이라고 한다.wrapper클래스의 메소드들이다. 
* 유일하게 Character클래스만 파싱 기능을 제공하지 않는다. -> charAt()을 이용하면 된다.

파싱할 때 Long형의 뒤에 l을 붙히면 런타임에러가 뜬다.

"abc"의 값을 int형으로 파싱하면 런타임에러 NumberFormatException발생한다.

-----------------------------------------------------------------------------------

.valueOf():기본 자료형 값을 Wrapper 클래스 타입으로 변환시키는 메소드
.toString() : 필드값을 문자열로 반환하는 메소드

-----------------------------------------------------------------------------------
날짜와 시간을 다루는
Date와 Calender

Date는 java.util패키지 안에 있다. 

기본생성자 : 운영체제의 날짜/시간 정보를 이용해서 인스턴스 생성 

.getTime() -> 날짜 시간을 숫자화함.1970년 1월 1일 0시 0분 0초 이후 지난 시간을 밀리세컨드로 계산해서 long 타입으로 반환한다.
밀리세컨드 : 1/1000초

Calendar 클래스는 불변객체가 아니기 때문에 값을 수정할 수 있다.
윤초를 고려하지 않는다. 
1~12월이아니라 0~11로 표현하지만 일주일의 시작은 1부터 시작이라 헷갈릴 수 있다.

Calendar는 추상클래스이다. 본인으로 객체를 만들지 않고 자식이 만들게 한다. GregorianCalendar이 자식 클래스이다.

Calendar인스턴스 받는법 
Calendar calendar = Calendar.getInstance();

.getTimeinMiilis()를 통해 밀리세컨드를 얻고

다시 Date date = new Date(birthDay.getTimeInMillis)안에 넣는다.

get()메소드 인덱싱을 통해 연,월,일등등 필요한 정보들을 얻을 수 있지만 몇 번 인덱싱이 무엇을 나타냈는지 외우지 못하기 때문에 상수 필드로 정의 놓았다. 
ex) birthDay.get(Calendar.YEAR);

Date와 Calendar클래스의 불편을 해소하고자 Time패키지가 등장하였다. Calandar와 다르게 불변하기 때문에 안전하다.
-------------------------------------------------------------------------
Time패키지 핵심 클래스
LocalTime - 시간 관련
LocalDate - 날짜 관련
LocalDateTime - 시간과 날짜 관련
ZonedDateTime - 시간대를 활용한 작업

인텔리제이 자동 import 기능 settings들어가서 import검색 후 AutoImport의 Add unambiguous imports onthe fly 체크박스 체크

LocalTime.now():현재의시간
LocalTime.of(18,30,0) : 원하는 시간 만들 수 있음

time 필드값 변경 : with,plus,minus로 시작하는 메소드로 가지고 있는 값을 변경시킬 수 있다.

날짜 시간 비교 isAfter(),isBefore(),isEqual

문자열을 parse를 통해서 Date,Time클래스로 바꿀 수 있다. 하지만 형식이 옳바르지않은 String형이라면 format이 필요하다. 


















