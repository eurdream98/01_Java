01.17

오류 : 개발자가 미리 예측하거나 코드로 처리하는 것이 불가능 한 경우 ex)JVM에러,정전
예외 : 코드가 전개되는 상황에서 발생할 수 있는 개발자가 미리 예측하고 처리할 수 있는 미약한 오류

코드의 흐름을 컨트롤(비정상적인 종료를 하게할 수도 있고 아닐 수도 있다.) 할 수 있다.

NullPointerException같은 뭐뭐Exception은 모두 클래스이다. java.lang패키지 안에있는

Error는 하드웨어 상으로 나타나에러이기 때문에 몰라도 괜찮다. 모든 예외들은 Exception인터페이스를 상속한다.

IOException은 파일 입출력 관련된 예외 인터페이스로 많이 사용된다. 예를들어 존재하지 않는 파일을 읽어오라는 명령문을 썼을 경우 FileNotFoundException이다. 이 때 파일이 없다면 ~~이런걸 해라고 하는 것이 예외 처리이다.

UncheckedException은 개발자가 반드시 예외 처리를 하지 않아도 컴파일 에러가 뜨지는 않는다.실행했을 때 오류가 생기는 모습을 확인할 수 있다.
CheckedException은 개발자가 반드시 예외처리 코드를 작성해야하는 예외이다. 만약 예외 처리를 하지 않으면 컴파일 에러가 뜬다

RuntimeException

ArithmethicException - 0으로 나누는 경우 발생
ArrayIndexOutOfBoundsException은 배열의 index범위를 넘어갔을 경우 생기는 오류이다.
ClasssCastException -> 형번환 시 자료형에 문제가 있을 때 발생
NegativeArrayException -> 배열의 인덱스에 음수를 입력하였을 경우 생기는 오류

예외를 강제로 발생시키고 싶다면 throw 발생시키고 싶은 객체를 입력하면 된다.

발생시키고 싶으면 throw이고 메소드 시그니쳐 부분에는 throws를 작성한다. 
예외가 발생시키려면 예외 처리가 필요하다. 첫 번째 예외 처리 방법은 메소드 시그니처에 throws구문을 작성하는 것이다. 예외처리를 강제화하는 것이다.

예외가 나타나면 뒤의 코드는 실행하지 않고 나를 호출한 곳으로 리턴하고 다시 throws로 미룬다. => 프로그램을 비정상적으로 종료하겠다.

코드가 끝나고 콘솔창에 뜨는 Process finished with exit code 1에 마지막 숫자가 1이면 비정상적인 종료이고 0이면 정상 종료이다. 

예외를 처리하는 두 번째 방법으로는 trycatch가 있다. try{}안에는 예외가 발생할 가능성이 있는 코드를 넣고 예외가 발생하지 않았을 경우 실행될 코드도 아래에 적어준다. 이 때 예외가 발생하면 아래 코드 실행을 멈추고 catch블럭으로 이동하게 된다.즉, catch안에는 예외가 발생했을 경우의 코드를 작성해준다. 
throws로 위임을 했을 때 trycatch를해주면 정상수행흐름을 타지만  main까지 위임을 해준다면 정상작동하지 않는다.

exception이 발생하면 메소드에서 위임힌다. 예외 객체가 던져져서 catch(Excetption e)처럼 catch안의 객체로 나타난다.

e.printStackTrace(); -> 에러 메시지를 출력하라. * 프로그램이 비정상적으로 끝난 것은 아님

catch여러개 붙히기 가능

finally라는 블럭은 예외여부 상관없이 꼭 실행되는 코드이다. 자원 반납을 위해 주로 사용된다.

클래스는 사용자가 정의한 자료형인데 예외역시도 사용자가 정의해서 사용할 수 있다.

Exception은 논리적인 분류이다. 주로 생성자밖에 없고 메소드는 없다. Throwable인터페이스에는 여러 메소드들이 정의되어있지만 상세한 자식 클래스들은 이럴때 발생하는 에러이다!라고 논리적인 분류만 해준 느낌이다. 
-> 예외를 만들고 생성자만 정의해준다면 내가 설정한 예외를 만들 수 있다.
extends Exception을 통해 예외 처리 클래스를 상속받아 더 구체적인 예외 이름을 정의하는 것이다.

Excpetion클래스를 만들고 생성자를 만들어 매개변수로 message를 넣고 super(message)를 넣어 부모 클래스로 올라가보면 Extends역시 super(message)를 보내고 있고 다시 올라가보면 throwable에서 메시지를 출력하는 기능을 가진다. 상위 타입으로 전달 된 메시지는 Throwable의 detailMessage라는 필드에 설정된다.

만약에 RuntimeExcpetion을 상속받는다면 예외처리가 강제화 되지는 않는다.Exception을 상속받아  예외처리 강제화를 시켜주자. 

throws 구문 작성 시 여러 Exception을 나열할 수 있으며 상위 타입의 Exception만 작성할 수도 있다.

e.getMessage() => message를 가져옴

trycatch구문에서 예외를 각각의 상황에 따라 해주려면 여러개의 catch를 사용하여 쓸 수 있고 통합해서 처리하고 싶다면 Exception으로 받아 한번에 처리해줄 수 있다.

여러개의 catch문을 쓸 경우 상위 타입이 이미 위에 나타난 경우 아래에서 하위타입이 나타날 수 없다.

같은 레벨의 Exception클래스는 |로 나열하여 사용할 수 있다. 단 상위 클래스인 경우에는 같이 나열하면 안된다. 이때 상위클래스라는 것은 내포하고 있고의 여부이다.

파일 입출력에서 예외가 발생했던 안했던 사용한 자원을 반드시 반납해줘야한다. 

자원의 반납 .close() 메소드 사용 그런데 try{}블럭 내부에서 자원을 선언해주었기 때문에 finally안에서는 모르기 때문에 자원 선언을 try밖으로 꺼내 주어야 finally에서도 인식 가능하다.

try with resource문법을 통해 자동으로 close처리가 가능하다.

부모클래스와 자식클래스 사이에서 오버라이드된 메소드는 예외 역시 같거나 더 구체적이여야한다. 

상속 관계에서 예외를 떼거나 똑같이하거나 위로 올리는 것은 불가능하다. 
-----------------------------------------------------------------------------------------------------

입출력

입출력 장치에서 데이터를 읽고 쓰기 위한 단방향 통로로 자바에서 제공하는 클래스이다.

문자를 바이트 단위로 읽어올 것이냐 문자 단위로 처리할 것이냐의 차이가 있다.
두번째로 입력스트림과 출력스트림이있다.

입출력을 사용하는 이유 파일 형태로 프로그램의 종료와 상관없이 영구적으로 데이터를 저장할 수 있다. -> 데이터 베이스의 원천이였음

영어나 숫자는 한글자여서 바이트 단위로 나누기 가능하지만 한글은 그렇지 않다.

File클래스는 파일 객체를 다루기 위한 클래스이다. java.io패키지 안에 있는 클래스이다. 

File클래스는 기본생성자가 없기 때문에 객체 생성 시 파라미터를 넣어주어야한다.

File file = new File("test.txt"); 물리적인 파일이 아직은 만들어지지 않은 상태이다.

.createSuccess()메소드를 통해 물리적으로 파일을 만들고 새로 만들었다면 true값,새로 만들지 않았다면 false값을 리턴한다. 자바 프로그램 내에서 driectory쪽으로 파일을 만들어달라고 명령을 하였다.

file.length() = 파일의 크기
file.getPath() = 파일의 경로
file.getParaent() = 파일의 상위 경로
file.getAbsolutePath() = 파일의 절대 경로

경로 = 상대경로 :  현재 프로젝트 기준으로의 경로
상위 경로 : 
절대 경로 : C드라이브를 기준으로의 경로

file.delete() ->파일 삭제

클래스를 보았을 경우 byte기반?문자기반?인지를 확인하고 입력?출력?인지를 확인한다. 
(Stream으로 끝나는 클래스면 byte기반이다. )

.read() 을통해 계속 읽어오다가 더 이상 가져올 것이 없으면 -1을 반환한다.
byte값으로 읽어옴 ex) abcd -> 97 98 99 100
한글은 1byte씩 끊어올 수 없기 때문에 읽혀지지 않는다.

한글 값의 경우 1바이트를 초과하므로 1바이트씩 끊어서 읽어왔을 때 깨지는 현상을 볼 수 있다.

파일과 프로그램 사이에 Stream이라는 통로가 있다. 프로그램에서 명령어를 요청하고 이 때 Stream은 os가 빌려주는 것이다. 다시 돌려줘야해서 .close()를 finally에 쓴 것이다. 

1. 장기간 실행 중인 프로그램에서 스트림을 닫지 않으면 다양한 리소스에서 누수가 발생한다.

버퍼 : 데이터를 좀 쌓아서 보내기 위한 목적 

프로그램에서 입력한 값은 버퍼에 일정량이 담기면 File로 값이 이동하는데 이 때 stream을 쓴다. buffer에 잔류 데이터가 남아있고 stream을 반납하지 않은 상태로 새로운 파일에 값을 입력하기 위해 stream과 버퍼를 쓰려고하면 이미 사용 중이기 때문에 waiting형태로 남게되며 deadlock상태가 된다. 그래서 stream을 반납해야한다. 

new File(파일경로)의뜻은 파일경로에 있는 파일 내용을 담은 인스턴스를 만들어오겠다는 의미이다. 

.read()는 inputStream이든 reader이든 둘 다 반환 값이 int이다. 