01.19
람다식
함수형 프로그램이라고 불린다.

메소드를 하나의 식으로 표현한 것이다. 

원래 알고 있던 구조에서 메소드명과 리턴 값이 없는 형태이다. 익명함수라고도 할 수 있다. 

함수는 기능을 수행하는 애이다.

함수 안에 메서드가 있다.

메서드는 클래스 내에 선언된 함수의 일종이다.

람다식이 필요한 이유는 단순함 그리고 편함이다.

컬렉션과 스트림을 연계하여 람다식을 활용할 수 있다.

매개변수가 없는 경우는 ()->{}로 표현
매개변수가 1개만 있는 경우 매개변수 ->{} 로 표현
매개변수가 여러개 있는 경우 (매개변수1,매개변수2) -> {}로표현

매개변수의 자료형은 적지 않아도 된다.

인터페이스 내부에 하나의 추상 메소드가 선언 된 인터페이스만 람다식의 타깃이 될 수 있다.

@FunctionalInterface : 람다식의 타깃이 될 수 있는지 확인해주는 어노테이션

인터페이스에 추상메소드가 2개 있는 것은 문제가 없지만 함수적 인터페이스로 만들 의도라면 틀렸다. 하지만 이런의도를 컴퓨터는 알리가 없고 이런 의도를 전해주기 위해 위의 어노테이션을 활용하는 것이다. 

인터페이스에 정의 된 추상 메소드를 활용하기 위해서는 3가지 방법이 있다.
1. 인터페이스를 상속 받은 클래스를 정의하여 기능을 완성한 후 사용하는 방법
*인터페이스를 상속받은 클래스명은 마지막에 Impl을 붙혀서 만들어주는 경향이 있다.
2. 익명클래스를 이용한다. 
익명클래스를 쓰면 람다로 쓰는 것이 어떤지 추천해주고 있다.

람다식에 필요한 조건
람다식을 타깃으로 하는 함수형 인터페이스와 그 안의 추상메소드 단 1개

인터페이스를 내부에 중첩시킬 수 있다.(내부 인터페이스) 여러개의 인터페이스를 선언하고 내부에 추상메소드1개만을 적어 함수형인터페이스로 만들 수 있다. 

레퍼런스 변수가 참조하고 있는 것은 인터페이스이다. 

메소드는 항상 클래스 내부에 있어야하고 객체를 생성하여 호출할 수 있다. 

객체를 선언해줄 때 하나의 추상메소드만 선언되어있기 때문에 바로 람다식으로 간단하게 구체화할 수 있는 것이다.

표준함수적 인터페이스로 불리는 5가지가 존재한다. 표준함수적 인터페이스는 자주 쓰이는 메소드들의 매개변수들을 구현해놓은 것이다.

함수형인터페이스의 종류중 하나인 Consumer은 무언가를 매개변수로 받고 반환을 하지 않는다. .accept()메소드
consumer 함수형인터페이스는 매개변수를 받지만 활용할 수 있고 리턴 값을 받지않는 특징이 있다. 

Supplier : 매개변수가 없고 리턴 값이 있는 getXXX() 메소드를 가지고 있다. 

 Function : 매개변수와 리턴값이 있는 applyXXX() 메소드를 가지고 있다. (매개변수를 리턴값으로 매핑하는 역할)

Operator는 매개변수를 이용하여 연산을 한 후 동일한 타입으로 리턴해주는 것이다르다.

Predicate는 매개변수와 boolean 리턴 값이 있는 testxxx()를 가지고 있다.

자바에서 만들어져있는 5가지 계열의 함수적 인터페이스들을 제공해주고 있기때문에 직접 함수적 인터페이스를 설정한 후 사용하는 경우는 거의 없다. 

상속 관계에서 제네릭을 임시적으로 변경해도 괜찮다.

BinaryOperator은 BiFunction을 상속하고 있기 때문에 BiFunction의 추상클래스를 상속받고 있는 구조이다.

메소드 참조는 함수형 인터페이스를 람다식이 아닌 일반 메소드를 참조시켜 선언하는 방법이다.

일반메소드를 참조하기 위해서는 3가지 조건이 충족해야한다.  함수형 인터페이스의 매개변수 타입/갯수/반환형이랑 메소드의 매개변수 타입/갯수/반환 형이 같아야한다.

-----------------------------------------------------------------------------------------------------

Stream이란

컬렉션에 저장된 엘리먼트들을 하나씩 순회하면서 처리할 수 있는 기능이다.람다식과 함께 사용할 수 있으며 컬렉션에 들어있는 데이터에 대한 처리를 간결하게 표현할 수 있다.

스트림의 장점은 병렬처리가 가능하다는 것이다. 

그동안 순회를 반복문을 통해 진행하였지만 스트림에는 반복문이 내포되어있어 꺼내 쓰면 된다. 

Arrays.asList("hello","world","stream") 나열 된 글들을 하나의 Array로 만들어준다.이를 생성자 안에 넣어주면 그 값이 초기화 된다.

Iterable인터페이스 
foreach()메소드 : 반복문이 내부에 선언 되어 있다. 내부에 Consumer함수형 인터페이스를 매개변수로 넣어주고 이를foreach()괄호 안에서 메소드내용을 적어준다.

모든 작업은 기본적으로 main 스레드에서 일어난다.

Thread.currentThread().getName()현재의 작업을 어떤 쓰레드에서 해주고 있는지 나타내주는 명령어

parallelStream()은 병렬 스트림으로 바꿔준다. 

동작(System.out.println)을 매개변수로 넣어 실행해준다. 

스트림을 만드는 이유는 편안하게 순회하기 위함이다.

/*배열 스트림 생성*/
        String[] sarr = new String[]{"java","oracle","jdbc"};
        Stream<String> strStream1 = Arrays.stream(sarr);

Arrays.stream에서 매개변수 3개를 받으면 2번째 매개변수의 인덱스부터 3번째 매개변수의 인덱스전까지만 stream으로 만들겠다는 의미이다. 

컬렉션을 스트림으로 만드려면 Arrays.asList를 통해 배열을 List로 만들고 .stream메소드를 통해 만든다.

Builder를 활용하여 스트림 생성 builder()메소드를 활용하여 .add()를 통해 요소들을 만들어나가고 마지막에 .build를 통해 만들 수 있다. 

Stram형이되면 Stream에서 쓸 수 있는 여러가지 기능들이 있다.

iterator()를 활용하여 수열 형태의 스트림을 생성할 수 있다

기본 타입 스트림이 있다. 앞에 기본자료형을 붙힌 스트림이다.

사용한 스트림을 다시 사용하려고하면 오류가난다. 스트림은 소비형태이기때문에 다시 사용하려고하면 오류가 난다. 스트림의 특징:1회성임

특징2: 원본을 변경하지 않는 읽기 전용이다.

특징3: 최종연산 전까지 중간연산이 처리되지 않는다 ->중간연산 = 가공, 최종연산 = 생성EX)foreach()

특징 4: 병렬적으로 진행된다.

foreach는 최종 연산자로 다 출력되고나면 더이상 stream은 사용할 수 없게 되기 때문에 중간연산을 중간에 진행한 후 최종연산을 진행해줘야한다.

스트림의 중계 연산 중 하나인 filter에 대해 이해하고 사용할 수 있다.
 필터는 스트림에서 특정 데이터만 걸러내는 메소드로 매개변수로 받는 Predicate는 boolean을 리턴하는 함수형 인터페이스이다.

중계연산은 최종연산 전 까지 여러번 사용할 수 있다. 

filter()는 intstream을 반환하는 메소드이고 ()메소드 내부에서는 IntPredicate가 진행되며 boolean형을 반환하여 filter의 기능을 돕는다. 

flatmap은 중첩 구조를 한 단계 제거하고 단일 컬렉션으로 만들어준다. -> 플래트닝

스트림은 중간에 데이터를 가공하고자 사용하는 것일 뿐이다.

.sorted에 Comparator매개변수를 넣어 정렬하는방법에는 세가지가 있다.
1. implements Comparator를한 클래스
2. 익명클래스
3. 람다식

Comparator는 함수형인터페이스였다. -> 람다식으로 처리 가능

sorted(양수)이면 양수이면 두 값의 위치 바꾸고 음수이면 그대로 있는다.  

.collect()메소드는 List형으로 바꾸어주는 역할이다. 

최종연산 
1. calculating

optional 결과가 없을 수도 있다는 의미 

collect()메소드는 Stream->Collection으로 만들어주는 최종 연산이다.
.collect()메소드는 stream형태를 모아서 ()안에있는 형태로 만들어준다. 

anyMatch() 아무거나 하나라도 맞아? 

람다,스트림이 없어도 코딩을 못하는 것은 아니지만 더 쉬운 방법으로 코딩할 수 있다.

------------------------------------
필기 테스트 3차 오답노트

오버라이딩은 매개변수,리턴타입,메소드명 동일해야하고 접근제어자는 자식메소드의 접근제어자가 부모보다 같거나 넓어야함
오버로딩은 메소드명이 동일해야하고 리턴타입은 상관없고 매개변수가 달라야한다. 접근제어자는 자식메소드의 접근제어자가 상관 없다. 

4. 추상클래스 : 메소드 정의 사용에 대한 표준화 된 틀을 제공함. 일반메소드도 포함될 수 있기 때문에 일반 메소드를 상위타입에 넣어놓으면 중복을 줄일 수 있다는 말이다. 
인터페이스 : 메소드 정의 사용에 대한 표준화 된 틀을 제공함. 

13. String은 불변한다. 

14. 추상클래스는 생성자 만들 수 없다.

8. 메소드에 abstract와 static같이 쓸 수 없다.

22. 동적바인딩은 다형성때문에 나타난다. 

33. Map자료형 순회하는 법 : .keySet()메소드로 set자료형으로 바꾼뒤 interator을 통해 Iterator자료형에 넣어주고 while문을 통해 도출 
