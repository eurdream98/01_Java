01.15

제네릭은 데이터의 타입을 일반화한다.

제네릭은 클래스로 제네릭 타입을 활용하여 하나의 클래스

일반화 된 T라고 선언한 뒤 객체를 만들 때 T에 Integer을 넣겠다고 하면 거기에 Integer을 넣고 사용하면 된다. 즉, T는 아무 타입이나 가능해진다. 

이 때 T는 타입변수라고 부르고 일반화 된 자료형 대신 사용하며 관례상 대문자를 쓰며 T가 아닌 다른 영문자를 사용해도 무방하다.T,E,V,K가 관례적으로 많이 쓰인다.

<T,A> 처럼 여러개의 타입 변수를 작성하는 것도 가능하다.

사용하는 쪽에서 작성한 제네릭 클래스를 이용할 때 실제 사용할 타입을 타입 변수 자리에 넣어주게 되면 컴파일 시점에 타입이 결정된다.

GenericTest<Integer> gt1 = new GenericTest<Integer>();객체를 생성할 때 다음과 같이 선언한다. 뒤의<Integer>은 앞에 이미 타입이 결정 되어있기 때문에 생략 가능하다.

제네릭 프로그래밍의 장점 : 데이터 타입에 의존하지 않기 때문에 재사용성이 높다.

T를 없애고 Object라고 쓰면 어떤 문제점이 있을까? Object는 어떤 타입이 되든 다 들어갈 수 있다. -> 1.타입 안정성이 떨어지게 된다. 제네릭스는 컴파일 시점에 타입이 결정된다.
2.instanceof와 다운 캐스팅 작성 불필요

기본자료형이 제네릭이 될 수는 없다. 

extends 키워드를 이용하여 특정 타입만 사용하도록 제네릭 범위를 제한 할 수 있다.

부모를 상속받은 클래스를 제네릭으로 사용하고 싶다면 <T extens Rabbit>처럼 활용하여 사용한다.

wildCard를 통해 메소드의 매개변수부를 제한할 수 있다. 

OOP의 4대특징의 궁극적인 목적 => 1. 유지보수성, 재사용성
=> 구체적으로 작성하면 그 상황에서밖에 쓰지 못하고 다른 상황에서는 쓰지 못하게 된다.

-----------------------------------------------------------------------------------------------------

컬렉션

객체배열을 쓸 때 LowLevel의 로직들을 많이 쓰게 된다.
예를들어 회원 관리를 하기 위한 Member[] members = new Member[100]; 만약 2번 인덱스에 있는 회원이 탈퇴를하면 null값이 되면서 출력시 nullpointerException이 될 것이다. 이를 방지하기 위해 비어 있는 공간을 메우기 위해 앞으로 땡길 것이다. 혹은 중간에 회원 정보를 삽입하고 싶을 경우 인덱스를 밀거나 땡겨야할 경우가 있을 것이다. 
-> 많은 데이터들을 효과적으로 처리할 수 있는 방법을 제공하는 클래스들의 집합이다.

Collection인터페이스는 크게 List,Set,Queue 3가지 상위 인터페이스를 갖는다. 구조상의 이유로 Map은 따로 구현되어있다. 

List : 순서가 있고 데이터중복 허용

ArrayList
        * ArrayList는 배열의 단점을 보완하기 위해 만들어졌다.
        * 배열은 크기를 변경할 수 없고, 요소의 추가, 삭제 , 정렬 등이 복잡하다.
        * 이러한 기능들을 ArrayList에서 미리 메소드를 구현해서 제공하고 있으며
        * 내부적으로 수행 될 뿐이지 실행 속도가 빨라지는 것은 아니다.

Collection인터페이스는 모두 java.util패키지 안에 있다.

ArrayList는 인스턴스를 생성하면 내부적으로 10칸짜리 배열을 생성해서 관리한다.

ArrayList는 List의  후손이기 때문에 다형성을 이용하여 선언할 수 있다.
구체적이지 않게 쓰는 것이 자바에서는 좋기 때문에 List로 선언하는 것이 좋다.
/*더 상위 타입인 Collecton 타입을 사용할 수도 있다.*/
        Collection clist = new ArrayList();
list의 레퍼런스 배열을 출력하면 주소값이 나오지 않는다. 레퍼런스 배열을 출력하면 .toString()이 자동으로 적혀 배열 값들이 출력된다.

.size()를 통해 값들이 담긴 길이를 알려주고 총 길이는 알려주지 않는다.

배열에서는 리스트[인덱스번호]를 통해 값을 가져올 수있었지만 list는 .get()을 통해 가져올 수 있다.

alist의 특징
1. 순서대로 저장된다.
2. 중복 데이터 저장 가능하다.

.add(넣을 인덱스,넣을 값) -> 하나씩 밀려남

Collection은 인터페이스, Collections은 클래스로 Collection에서 필요한 메소드들이 선언되어 있다. ex)Collections.sort(배열명)

sort메소드를 사용하면 오름차순으로 배열이 정렬되고 원본에 영향을 끼친다.

sort() 메소드에서 내부적으로 compare 메소드를 호출하여 swap 여부를 결정한다.

/*Comparator 사용 시 제네릭 선언을 함께 해주어야 compare 메소드의 매개변수 타입이 정의 된다.
* Object 타입인 경우 다운 캐스팅 해서 사용해야 하므로 제네릭 타입을 결정해주고 사용하는 것이 좋다.*/

비교 대상 두 인스턴스의 가격이 오름차순 정렬이 되기 위해서는 앞의 가격이 더 작은 가격이어야 한다. 만약 뒤의 가격이 더 작은 경우에는 두 인스턴스의 순서를 바꾸어야 한다.그 때 두 값을 바꾸라는 신호로 양수를 반환하면 정렬 시 순서를 바꾸는 조건으로 사용된다.

---------------------------------------------------------------------------------------------------

익명클래스
한 번만 사용하고 유기할 클래스

 앞에게 더 크면 음수 혹은 0 나옴
 뒤에게 더크면 양수 나옴

문자열 오름차순,내림차순 -> compartTo()메소드 이용 

Vector 동기화o,  ArrayList는 동기화 지원 x
쓰레드가 여러개일 때 동기화가 지원 되는 것이 좋다. 동기화가 되는 것은 성능이 떨어지기 때문에 요즘에는 ArrayList를많이 쓴다.
















