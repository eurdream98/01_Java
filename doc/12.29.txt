12.29

println오류 -> File -> invalid caches->캐시삭제

형변환은 두가지가 있다.
자동형변환 - 컴파일러가 해줌(작은 범위에서 큰 범위로 옮길 때 일어남)
강제형변환 - 개발자가 해야함(큰 범위에서 작은 범위로 옮길 때 데이터 손실가능성을
감수하고 개발자가 강제로 형변환해주는 것)

int i = (int) lnum -> (int)는 형변환 연산자, casting연산자

부호비트 1은 마이너스, 0은 플러스

int미만의 연산(모든 연산 결과)에서는 처리 결과는 int형이다.
ex)
byte+byte
byte+short
short+short
모두 결과가 int형이다.

형변환 원칙
* 데이터가 손실되면 안되는데?
1. 작은 -> 큰
2. 정수 -> 실수
3. 문자 -> int 이상
4. 논리 x

----------------------------------------------------------------------
연산자

이항연산자란? 피연산자가 2개인 연산자<->단항연산자? 피연산자가 1개인 연산자

+=,-=,*=,/=,%=산술복합대입연산자라고한다.

num+=5
num=num+5일 때 위에거가 더 효율적임

++var/var++ 전위/후위
다른 연산자들과 함께 있을 때 후위연산자가 가장 마지막에 연산됨

비교연산자의 결과는 참혹은거짓이다

비교연산자에서 논리값과 문자열 비교는 크다 작다는 안되고 같냐 같지않냐만 비교 가능하다.
* 문자열 비교에서 ==는 주소값을 비교하는 것이기 때문에 문자열 두개가 같은지 비교를 위해서는 왠만하면 문자열.equals(문자열2) 이런식으로 비교하는 것이 좋다.

&&,||는 이항연산자, !는 단항연산자이다.


&&는 ||보다 우선순위가 높다.

컴퓨터가 효율적으로 작동하기 위해 이미 결과가 나타난 연산에서는 뒤는 실행을 안함
논리식 && 논리식 : 앞 논리식이 false이면 뒤를 실행 안함
논리식 || 논리식 : 앞 논리식이 true이면 뒤를 실행 안함
효율성을 고려하면 &&연산에서는 false가 나올 것 같은 조건을 앞에 배치한다.
반대로 ||연산에서는 true가 나올 것 같은 조건을 앞에 배치한다.

연산순서
최우선연산자(괄호)->단항연산자->이항연산자(산술연산자->비교연산자->논리연산자)->삼항연산자->대입연산자->나열연산자

-----------------------------------------------------------------------
메소드

선언하고 호출을 해야 메소드가 실행됨.

.을찍는 행위를 참조연산자라고 함. 참조연산자를 통해 메소드를 가져올 수 있다.
ex)application01.methodA();

메소드가 실행되는동안 메소드 순서대로 stack에 공간을 할당하고 쌓인다. 메소드가 종료되면 공간에서 사라진다.

메소드가 시작하는 것은 호출,call이라고 하고메소드가 끝나는 것은 반환,return이라고 한다.

argument(전달인자),parameter(매개변수)차이점 이해하기


메소드를 선언할 때 어떠어떠한 값을 받겠습니다 정해놓은 것이 parameter라고 하고
메소드를 호출할 때 넣는 값을 argument라고한다.

전달인자의 자료형,갯수,순서가다르면 안된다.

매개변수는 지역변수로 분류된다.final 키워드도 사용 가능하다.

전달인자를 파라미터로 넘길 때 지역변수로 초기화를 하는 것이다.




