01.05

main메소드에서 return; -> 프로그램 종료

int 와 int의 나눗셈은 int형이다.

---------------------------------------------------------------------------------------------------

2차원 배열

1차원 배열을 여러개 묶은 것

할당할 때는 길이로 선언하고 접근할 때는 인덱스로 접근하기 때문에 헷갈리지 않게 주의하자.

각각의 1차원 배열들의 주소값을 레퍼런스 배열이 갖고 있는 형태이다.
레퍼런스 배열
stack영역의 레퍼런스변수는 레퍼런스 배열의 주소값을 갖고 있고 레퍼런스배열은 1차원 배열들의 주소값을 갖고 있다.

heap영역에는 값이 없는 상태로 공간을 생성할 수 없다. 그렇다면 레퍼런스 배열에는 어떤 값이 담겨져 있을까? -> null값이 담겨있다.
ex) iarr1 = new int[3][]

2차원 가변배열(각각의 1차원 배열의 길이가 다름)
2차원 정변배열(각각의 1차원 배열의 길이가 같음)

iarr[0]이 null일 떄
iarr[0][0]을 출력하려하면 nullpointerexception이 뜬다. 왜냐하면 인식 할 수 있는 iarr[0]이 없는데 그것의 0번째 인덱스를 찾는 것은 말이 안되기 때문이다.

int[] arr = new int[5];
iarr[2] = arr; //미리 할당해둔 배열을 이용할 수 있음

------------------------------------------------------------------------------------------------------

배열의 복사 

인자,매개변수,리턴으로 배열을 활용하며 레퍼런스 변수의 주소값을 넘기면서 얕은 복사가 나타난다.

깊은복사 : heap영역에 물리적으로 영역을 새로 파고 같은 길이,같은 값을 설정해준 것,주소값이 다르게됨
언제쓰는가? ex) 정렬되지 않는 숫자들이 배열에 있을때 기존 배열은 정렬시키지 않고 새로운 배열에 정렬할 때, 동일한 값들을 갖게하고 뒤에 더 공간을 만들고 싶을 때 

깊은복사 하는 법 : 
1.반복문을 통해 
2. Object의 clone() 메소드를 통해 복제본(깊은 복사)을 만들어줌(동일한 길이,동일한 값, 다른 주소)
3.System에 있는 static메소드인 .arraycopy()를 통해 복사
파라미터 : 원본배열,복사 시작할 인덱스,복사본배열,복사 시작할 인덱스,복사할 길이
4. Arrays의 copyOf()를 이용한 복사 -> 시작 인덱스부터 원하는 길이만큼 복사해서 사용한다.

자바api가 기능구현을 위해 서로 사용되는 경우도 있다.

for each문 = 향상된 for문
for(int a : arr2(레퍼런스 변수 명)){
}향상된 for문에서는 값을 활용하는 것만 가능하고 바꾸는 것은 불가능하다. 복사해서 쓰는 것이기 때문이다.
int a값에는 arr2에서 복사해온 값이 저장된다.(얕은복사,깊은복사아님)























