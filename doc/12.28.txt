12.28

java를 배우는 이유
1. 많이 쓰기 때문에

jdk(jre,jvm)
1. oracle JDK(유료)
2. open JDK(무료)

복습
특정 버전은 오랫동안 지원해주겠다는 버전 (LTS)
8버전,11버전,17버전,21버전이있음

JDK를 깔았다고 편하게 개발을 할 수 있는 것이 아니다.
편하게 개발할 수 있는 통합개발환경이 필요하다.

IDE(Eclipse,VScode,Intellj)

Intellij에는 두가지 버전이 존재한다.

----------------------------------------------------------------------
1. 변수 
* 앞으로 많은 용어들이 나온다(영어)-용어 잘 정리해야함
리터럴이란? 변하지 않는 데이터 그 자체를 말한다. 단순 데이터라고 생각하면 편하다.

정수 실수 차이 : 소수점이 붙냐 안 붙냐

0b : 2진법
0: 8진법
0x: 16진법
-중요하지는 않음

10진법
2진법

e8: 제곱을 의미함(몇 승을 의미함)

'':싱글 쿼테이션
"": 더블 쿼테이션

.idea : 인텔리제이를 사용할 때의 설정정보가 들어있는 파일 건들 필요 x

src밑에 3개의 폴더를 만드는 것이 일반임(3레벨 이상으로 만듦)
앞에 두개는 회사에 관련된 파일 이름으로함.
com
ㄴohgiraffers(회사명)
   ㄴ section01(프로젝트명)

위에 톱니바퀴-> tree appearane -> compact =패키지의 계층 구조로 바꾸는 버튼

눈에보이는 빨간줄 : 컴파일 에러 
파일 이름 xxx.java 이라는 파일이 작동하기 위해서는 compile을 통해 xxx.class라는 확장자를 가진 파일로 바꿔준 것을 jvm이 구동시키는 구조이다.
그렇다면 컴파일 에러라는 뜻은? 문법적으로 맞지 않으니까 올바르게 해석이 불가능하다.=compile과정에서 오류가 났다.

코드를 써서 작업을 하기 위해서는 무조건 main메소드 안에서 작동해야한다.

바로 다음줄 단축키 : shift 엔터

메소드 => 만들어진 기능

싱글 쿼테이션 안에는 문자 한개만 -> 2개 혹은 0개 안됨

"a"와 'a'는 리터럴의 형태가 다르다.

println-> ln=line이라는 의미 line 개행

컴파일 .java 파일이 -> .class파일로 변환되는 과정 -> jvm을 통해 구현 됨

위에 out패키지에 있는 파일은 .class파일이다. 결국 구동되는 파일은 위에 파일이다.
out은 컴파일 된 내용들이 담겨있다.

%는 mode연산자라고 부름

부동소수점 방식 - 가수와 지수로 실수를 나타내는 방식 -약간의 오차가 발생한다.
-> 실수와 실수의 나머지계산에서 디테일한 연산에서는 타입의 변환이 이루어져야할 경우가 있다.

다른 타입의 자료형끼리 계산하는 것이 불가능하기 때문에 정수와 실수의 계산에서는 정수의 자료형을 실수형으로 바꾼 후 계산이 일어난다.(자동 형변환)

아스키코드는 영어만 취급할 수있는 단점이 있었다. 이를 보완하고자 유니코드가 나타났다. 전세계언어를 취급할 수 있도록함. UTF-8인코딩도 유니코드에 기반한 인코딩 방식 중 하나이다.

문자와 정수의 연산에서 문자형을 정수로 바꿔서 계산이 일어남

문자와 실수의 연산에서 문자형을 실수로 바꿔서 계산이 일어남

문자열은 덧셈만 가능하다.(이어붙히기로 생각하면됨)

논리형은 +연산에서 문자열과 합치기만 가능하다.다른 연산과 자료형은 아예불가능!

-----------------------------------------------------------------------

변수 = 변하는 수라고 생각하지 말고 변수는 데이터를 저장하기 위한 메모리 공간으로 생각하자

변수를 사용하기 위해서는 변수를 선언해야한다. 변수는 메모리에 저장할 공간을 만드는 것이다. 이때 만들 때 저 공간에 대한 크기,이름을 정해주어야 한다.

자료형은 크기를 규정해주는 것이다. ex) int는 4byte이다. 
ex)int age -> 메모리 공간의 크기를 4byte라고 하고 이 공간의 이름을 age라고 한다.

초기화 : 선언한 변수에 최초 값을 대입하는 것

선언과 초기화 동시에 가능
ex) 자료형 변수명 = 값;
--------선언----
                 -----초기화---

자료형은 기본자료형과 참조자료형으로 나누어진다.

1byte를 쪼개면 8bit이다.
한개의 bit에는 0또는 1이들어갈 수 있다.

int <- 대략적으로 21억정도 까지 표현할 수 있다.
넘어갈 것 같다면 long을 통해 더욱 데이터 표현범위를 증가 시킬 수 있다.

할당되는 크기가 다 다른 이유는 효율적으로 메모리 공간을 활용하기 위함이다.

맨 앞자리를 부호비트라고 한다. 부호비트가0이면 양수이고 1이면 음수이다.값은 총 7비트안에 표현하고 나머지 1비트는 음양을 결정하는데에 사용한다.

실수는 byte수가 커질수록 더욱 정확하게 표현할 수 있다. 마찬가지로 부호비트가 존재한다.

문자형 역시 short자료형 처럼 2byte였지만 short는 -부터 +까지 표현하기 때문에 문자형은 +만 표현하기 때문에 부호비트가 없다.

문자열을 참조자료형이다.
--------------------------------------------------------------------
같은 패키지에 같은 클래스명의 파일을 만들 수는 없다.

Long타입은 정확하게 표현하기 위해서는 8L처럼 뒤에 대문자 L이나 소문자 l을 붙혀야함. 왜냐하면 byte,short,int는 int리터럴로 보기 때문이다.

리터럴에서 그냥 정수나 실수는 int형이고 Long형이나 float형으로 나타내기 위해서는 뒤에 F나 L을 붙혀 표현해주어야한다.

= 대입 연산자라고함

왜 리터럴을 안쓰고 변수를 쓰면 좋을까(변수를 사용하는 목적)?
1. 값에 의미를 부여할 수 있다.
2. 재사용성이 높아짐
3. 시간에 따라 변경되는 값을 저장하고 사용할 수 있다.

-----------------------------------------------------------------------
상수
한번 저장된 데이터는 변경할 수 없다.

초기화 이후 값 변경시 컴파일 에러 일으킴

상수는 대문자로 쓴다.

--------------------------------------------------------------------
오버플로우

byte num1 = 127;
num1++;
sout(num1) -> 오버플로우로 -128이 나오지만

byte num1 = 127;
sout(num1+1)에 있는 num1을 그냥 값 자체를 가져온 것이다.

----------------------------------------------------------------------
형변환

형변환이 필요한 이유 : 컴퓨터는 기본적으로 같은 자료형끼리 연산이 가능하기 때문이다. 왼쪽과 오른쪽을 자료형이 같아야한다.

char형을 short형으로 바꾸고 short형을 char형으로 바꾸는 것은 부호때문에 되질 않는다.





































