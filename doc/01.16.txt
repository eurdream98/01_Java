01.16
복습
Collection : 자료구조 프레임워크

프레임워크 = 틀

Set -> 순서 x, 중복 x

제네릭스는 컬렉션에 모두 적용되어 있다.

List<E> -> element

remove(E e) -> element를 전달해서 삭제할 수 있다.
-------------------------------------------------------------------------------------------------------

LinkedList 도 ArrayList와 마찬가지로 List의 후손이다. 다만 저장이 되는 구조가 약간 다르다.

배열은 heap에 연속적인 공간이 만들어진다. LinkedList는 어떤 순서로 저장되어 있는지를 알기 위해서 다음 링크 주소값도 갖고 있다. 

마지막 데이터는 다음 링크 주소값이 null이다.

이전 링크주소도 갖고 있는 버전도 있다. 버전2개

데이터가 연속적인 공간에 저장되는 것이 아니다. 

배열과 가지는 가장 큰 차이점은 데이터의 삽입,삭제가 빈번할 경우 ArrayList보다 더 적합하다. 배열에서의 삽입,삭제는 인덱스의 수정이 매우 많이 필요해지지만 LinkedList는 삽입과 삭제한다고 했을 때 뒤의 주소값만 바꿔서 바꿀 수 있다.

LinekdList는 연속적인 공간에 담기지 않기 때문에 인덱스를활용할 수 없기 때문에 조회 성능이 낮다.

부모클래스인 List에 메소드들이 있고 자식 클래스인 ArrayList와 LinkedList가 그 메소드들(add,remove,,,)을 오버라이딩하고 있기 때문에 메소드명이 같게 사용하면 편하다. 

.clear()비워
.isEmpty() 비었으면 true,아니면 false출력

Stack은 Vector을 상속하고 Vector은 List가 상속하고 있는 구조이다. 

Vector은 동기화가 되어있고 ArrayList는 동기화가 안되어있다. 동기화가 되어있다는 말은 성능이 느리다는 말과 같다. 그래서 Vector은 쓰지 않고 그의 자식인 Stack을 주로 쓴다.

Stack은 메소드 호출 구조이다.메소드가 쌓이는 공간이다.처음 쌓인 것은 가장 마지막에 삭제된다 .-> firstin lastout -> FILO

Stack에 데이터를 넣는 것을 push라고하고 데이터를 삭제하는 것을 pop이라고 한다.

Stack에서는 인덱스말고 위에서부터의 순번을 통해 찾을 수 있다. -> 가장 상단의 위치는 0이아니라 1이다.

빈 스택에 접근할 시 EmptyStackException이 발생 

Queue는 인터페이스이므로 인스턴스 생성이 불가능하여 주로 LinekedList타입을 활용해서 큐를 만든다.

que에서는 더 꺼낼 값이 없다면 null이 나타난다. 오류가 뜨질 않고

가장 많이 쓰이는 자료형은 ArrayList이다.

Set은 순서가 없고 중복되지 않은 데이터를 저장하는 자료구조이다.

hash연산 : input을 받고 hash연산을 하여 output으로 hashCode가 도출 된다.hash연산을 통해 자료구조를 저장하고 탐색할 때 더 효율적으로 정리하여 저장하고 탐색할 수 있다.

hashSet : 해시 연산 결과를 통해서 저장 /저장 순서 유지 x

hashSet은 저장 순서가 유지 되지 않는다.

동일객체 뿐만아니라 동등객체도 동일한 객체로 인식한다.. 이유는 equals()와 hashCode()메소드가 String에 오버라이딩 되어있기 때문에 

각 클래스에서 equals와 hashCode가 동등 객체를 같다고 오버라이딩 되어있다면 같은 값으로 보고 추가하지 않는다.반대로 오버라이딩 되어있지 않다면 다른 값으로 보고 추가한다.
contains()메소드는 해당 객체를 포함하고 있는지 확인하는 메소드로 역서도 동등 객체로 판단한다.내부적으로 equals()메소드를 호출해서 사용하기 때문에 동등객체판단이 포함되어있다..

저장 된 객체를 인덱스 기준으로 순회할 수 없다.
        * 반복문을 이용한 연속처리 방법으로는
        * 1. toArray()메소드로 배열로 변경한 뒤 for loop 사용
        * 2. inerator() 메소드로 반복자를 만들어서 연속 처리

Iterator : 반복자
Iterabel인터페이스의 메소드이다.
iterator()메소드를 사용하여 Iterator인터페이스에 저장해주고 이를 while문과 .hasNext()와 .next()를 사용하여 순회한다. 

LinkedHashSet은 일반 HashSet과는 다른 점이 순서대로 저장한다는 점이다. 

TreeSet클래스는 데이터가 정렬된 상태로 저장되는 이진 검색 트리의 형태로 요소를 저장한다.
데이터를 트리 구조로 나눌 때 맨 위를 부모노드(root), 맨 아래의 노드를 자식노드(leaf)라고 한다.

예를들어 5라는 노드가 있을 때 5보다 작으면 왼쪽에 저장, 5보다 크면 오른쪽에 저장하고 7은 10으로 가고 10보다 작기 때문에 왼쪽으로 가는 구조이다.

부모에서 자식으로의 연결 선이 두개 있는 것이 이진 트리이다. 

TreeSet은이미 정렬이 되어있는 상태이다..

즉 값을 넣은 순서대로 정렬 되는 것이아니라 오름차순으로 정렬된다. 

TreeSet<클래스>는 정렬 기준이 없기 때문에 정렬이 되지를 않기 때문에 작동이 되지를 않는다. 정렬하는 법 : 클래스에 compareTo를 오버라이딩하여 정렬기준을 정의해줄 것

ArrayList만 배열처럼 저장되는 것이고 LinkedList는 연속되지 않은 공간이기 때문에 내부적으로 배열에 저장되는 것이 아니다.

Map - 키와 값을 쌍으로 저장하는 자료구조이다.,저장순서 상관 x, key=value
키는 중복 저장하지 않는다. (동일한 키 값을 넣어주면 value값 덮어쓰기가 일어난다.),value 값은 같아도 괜찮다. 

키는 구분자이고 값은 데이터를 나타낸다.

HashMap,HashTable,TreeMap -> HashTable은 거의 쓰지를 않는다.

keySet()메소드를 통해 key값들만 모아 set형태로 만들어줄 수 있다.->Iterator에 저장

values()메소드를 통해 value객체들만 가져올 수 있다.->Collection에 저장

hash 라고 쓰여있는 것은 조회에 유리하다. hash의 결과를 테이블에 정리해서 저장해 놓기 때문이다.

키와 value 를 합쳐 entry라고 부른다.

entrySet()메소드를 사용하여 저장해준다.

itreator메소드는 Set만 사용가능하다.

List는 인덱싱또는 .get()을 통해 순회할 수 있지만 Map은 순회하려면 Set으로 바꿔준 후 Iterator을통해 접근한다. 

자료구조별 접근
배열 인덱스로 접근
List get()으로 접근 *Stack은 search()로도 접근 가능
Set  Iterator()로 접근
Map get()또는 Iterator로 접근 * Map인터페이스의 Entry인터페이스를 통해 키와 value값을 동시에 접근가능 .getKey()와 .getValue()이용 

HashTable을 상속 받은 Properties는 (String,String)으로 고정되어 있다. 환경 설정과 관련된 속성을 저장하는데 사용한다. 제네릭 필요없음 


 
